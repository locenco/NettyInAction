# 3.1Netty 速成

在开始之前，如果您对Netty应用程序的基本结构有一个大概的了解（客户端和服务器都具有相似的结构），这将很有用。

Netty应用程序以Bootstrap类开始，Bootstrap是Netty提供的一种构造，使您可以轻松配置Netty如何设置或引导应用程序。

为了允许多种协议和多种处理数据的方式，Netty具有所谓的处理程序。顾名思义，处理程序旨在处理Netty中的特定事件或事件集。事件是描述此事件的一种非常通用的方式，因为您可以拥有一个处理程序，将对象转换为字节或反之亦然，或者您可以拥有一个处理程序，该处理程序将收到有关在处理过程中引发的异常并对其进行处理的通知。

您将要编写的一种非常常见的类型是ChannelInboundHandler的实现。 ChannelInboundHandler接收消息，您可以对其进行处理并决定如何处理它。当您的应用程序需要提供响应时，您也可以从ChannelInboundHandler内部写入/刷新数据。换句话说，应用程序的业务逻辑通常位于ChannelInboundHandler中。

> 业务逻辑
>
> 业务逻辑代表程序的一部分：它对通过网络接收到的数据转换为某种易于理解的格式后进行实际的处理。

当Netty连接客户端或绑定服务器时，它需要知道如何处理发送或接收的消息。这也可以通过不同类型的处理程序来完成，但是要配置这些处理程序，Netty有一个ChannelInitializer。ChannelInitializer的作用是将ChannelHandler实现添加到所谓的ChannelPipeline中。在您发送和接收消息时，这些处理程序将确定消息发生了什么。ChannelInitializer本身也是一个ChannelHandler，在添加了其他处理程序之后，它会自动从ChannelPipeline中删除自身。

所有Netty应用程序都基于所谓的**ChannelPipeline**。 ChannelPipeline与所谓的EventLoop和EventLoopGroup密切相关，因为它们全部与事件或事件处理有关。

应用程序中的EventLoops用途是**处理通道的IO操作**。一个EventLoop通常将处理多个通道的事件。EventLoopGroup本身可能包含一个以上的EventLoop，并可用于获取一个EventLoop。

Channel是套接字连接或某些能够执行IO操作的组件的表示，因此为什么要由EventLoop对其进行处理，而EventLoop的任务是处理IO。

Netty中的所有IO操作都是异步执行的。因此，例如，当您连接到主机时，默认情况下这是异步完成的。编写/发送消息时也是如此。这意味着该操作可能不会直接执行，而是在以后执行。因此，您无法知道操作返回后是否成功，但是需要稍后能够检查是否成功，或者需要某种方式注册被通知的侦听器。为了解决这个问题，Netty使用了Futures和ChannelFutures。future 可用于注册侦听器，当操作失败或成功完成时，将通知该侦听器。

> 什么是ChannelFuture？
>
> 如前所述，所有IO操作在Netty中都是异步的，因此可能稍后执行，而不是直接在执行方法时完成。这是ChannelFuture发挥作用的地方。ChannelFuture是特殊的java.util.concurrent.Future，它允许您将ChannnelFutureListeners注册到ChannelFuture。一旦操作（由方法调用触发）完成，那些ChannelFutureListener将会得到通知。
>
> 因此，基本上，ChannelFuture是占位符，表示将来执行的操作的结果。何时确切执行它取决于许多事实，而且很难说。您唯一可以确定的是它将被执行，**并且所有返回ChannelFuture并属于同一Channel的操作都将以正确的顺序执行,这与您执行方法的顺序相同**。

在阅读本章和本书的其余部分时，您会发现这些概念经常被提及。但是它们并不太复杂，因此，如果您觉得每个组件的详细说明看起来很复杂，请跳回本节并重新阅读简化版本。

在本章的其余部分，我们将扩展刚才提到的所有内容。

