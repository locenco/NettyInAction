# 5.3 ByteBuf的字节操作

ByteBuf提供了许多允许修改内容或仅读取内容的操作。您将很快了解到它非常类似于JDK的ByteBuffer，它提供了更好的用户体验和性能。

## 5.3.1 随机访问索引

像普通的原始字节数组一样，ByteBuf使用基于零的索引。这意味着第一个字节的索引始终为0，最后一个字节的索引始终为-1。例如，我可以迭代缓冲区的所有字节（请参见下面的清单），而不管其内部实现如何。

```text
 /**
     * Listing 5.6 Access data
     */
    public static void byteBufRelativeAccess() {
        ByteBuf buffer = BYTE_BUF_FROM_SOMEWHERE; //get reference form somewhere
        for (int i = 0; i < buffer.capacity(); i++) {
            byte b = buffer.getByte(i);
            System.out.println((char) b);
        }
    }

```

请注意，通过索引进行的访问不会提升readerIndex或writerIndex。如果需要，您可以通过调用readerIndex（index）和writerIndex（index）来手动推进。

## 5.3.2 顺序访问索引

ByteBuf提供两个指针变量，分别支持顺序的读写操作readerIndex用于读操作，而writerIndex用于写操作。同样，这与JDK的ByteBuffer只有一个不同，因此您需要flip（）在读和写模式之间切换。图5.3显示了如何通过两个指针将缓冲区划分为三个区域。

![Figure 5.3 ByteBuf areas](../.gitbook/assets/image%20%2832%29.png)

## 5.3.3 可丢弃的字节 Discardable bytes

可丢弃字节段包含已由读取操作读取的字节，因此可以将其丢弃。最初，此段的大小为0，但随着执行读取操作，其大小增加到writerIndex。这仅包括读取操作；获取操作不会移动readerIndex。可以通过调用discardReadBytes（）回收未使用的空间来丢弃读取的字节。

![Figure 5.4 Before discardReadBytes is called.](../.gitbook/assets/image%20%2831%29.png)

正如您所看到的，可丢弃的字节段包含一些可重用的空间。 这可以通过调用discardReadBytes\(\)来实现。

图5.5显示了discardReadBytes（）的调用将如何影响分段。

![Figure 5.5 After discardReadBytes is called](../.gitbook/assets/image%20%2833%29.png)

注意，在调用discardReadBytes（）之后，无法保证可写字节的内容。在大多数情况下，可写字节不会移动，甚至可能会根据基础缓冲区的实现而用完全不同的数据填充。

另外，您可能会经常调用discardReadBytes（）来再次为ByteBuf提供更多可写空间。请注意，discardReadBytes（）最有可能涉及内存副本，因为它需要将可读字节（内容）移至ByteBuf的开头。这样的操作不是免费的，并且可能会影响性能，因此请仅在需要时使用它并从中受益。因此，例如，如果您需要尽快释放内存。



