# 6.2 ChannelHandlerContext

æ¯æ¬¡å°†ChannelHandleræ·»åŠ åˆ°ChannelPipelineæ—¶ï¼Œéƒ½ä¼šåˆ›å»ºå¹¶åˆ†é…ä¸€ä¸ªæ–°çš„ChannelHandlerContextã€‚ChannelHandlerContextå…è®¸ChannelHandlerä¸Žå…¶ä»–ChannelHandlerå®žçŽ°è¿›è¡Œäº¤äº’ï¼Œæœ€åŽä¸ŽåŸºç¡€ä¼ è¾“è¿›è¡Œäº¤äº’ï¼Œè¿™äº›ä¼ è¾“æ˜¯åŒä¸€ChannelPipelineçš„ä¸€éƒ¨åˆ†ã€‚

ChannelHandlerContextæ°¸è¿œä¸ä¼šä¸ºæ·»åŠ çš„ChannelHandleræ›´æ”¹ï¼Œå› æ­¤å¯ä»¥å®‰å…¨åœ°è¿›è¡Œç¼“å­˜ã€‚

ChannelHandlerContextå®žçŽ°ChannelInboundInvokerå’ŒChannelOutboundInvokerã€‚å®ƒå…·æœ‰è®¸å¤šæ–¹æ³•ï¼Œå®ƒä»¬ä¹Ÿå­˜åœ¨äºŽChannelæˆ–ChannelPipelineæœ¬èº«ä¸Šã€‚åŒºåˆ«åœ¨äºŽï¼Œå¦‚æžœæ‚¨åœ¨Channelæˆ–ChannelPipelineä¸Šè°ƒç”¨å®ƒä»¬ï¼Œåˆ™å®ƒä»¬å§‹ç»ˆæµç»å®Œæ•´çš„ChannelPipelineã€‚ç›¸åï¼Œå¦‚æžœåœ¨ChannelHandlerContextä¸Šè°ƒç”¨æ–¹æ³•ï¼Œåˆ™è¯¥æ–¹æ³•ä»Žå½“å‰ä½ç½®å¼€å§‹ï¼Œåœ¨å¯ä»¥å¤„ç†äº‹ä»¶çš„ChannelPipelineä¸­é€šçŸ¥ä¸´è¿‘çš„ChannelHandlerã€‚

## 6.2.1 é€šçŸ¥ä¸‹ä¸€ä¸ªChannelHandler

æ‚¨å¯ä»¥é€šè¿‡è°ƒç”¨ChannelInboundInvokerå’ŒChannelOutboundInvokerä¸­åˆ—å‡ºçš„å„ç§æ–¹æ³•ä¹‹ä¸€æ¥é€šçŸ¥åŒä¸€ChannelPiplineä¸­æœ€æŽ¥è¿‘çš„å¤„ç†ç¨‹åºã€‚é€šçŸ¥ä»Žä½•å¤„å¼€å§‹å–å†³äºŽæ‚¨å¦‚ä½•è®¾ç½®é€šçŸ¥ã€‚

å›¾6.2æ˜¾ç¤ºChannelHandlerContextå¦‚ä½•å±žäºŽChannelHandlerå¹¶å°†å…¶ç»‘å®šåˆ°ChannelPipelineã€‚

![](../.gitbook/assets/image%20%2846%29.png)

çŽ°åœ¨ï¼Œå¦‚æžœæ‚¨å¸Œæœ›äº‹ä»¶æµéåŠæ•´ä¸ªChannelPipelineï¼Œåˆ™æœ‰ä¸¤ç§ä¸åŒçš„æ–¹æ³•ï¼š

* Invoke methods on the Channel.
* Invoke methods on the ChannelPipeline.

ä¸¤ç§æ–¹æ³•éƒ½ä½¿äº‹ä»¶æµè¿‡æ•´ä¸ªChannelPipelineã€‚å®ƒæ˜¯ä»Žå¤´å¼€å§‹è¿˜æ˜¯ä»Žå¤´å¼€å§‹ä¸»è¦å–å†³äºŽäº‹ä»¶çš„æ€§è´¨ã€‚å¦‚æžœæ˜¯å…¥ç«™äº‹ä»¶ï¼Œåˆ™ä»Žå¤´å¼€å§‹ï¼Œå¦‚æžœæ˜¯å‡ºç«™äº‹ä»¶ï¼Œåˆ™ä»Žå¤´å¼€å§‹ã€‚

ä¸‹é¢çš„æ¸…å•æ˜¾ç¤ºäº†å¦‚ä½•ä»Žæœ€åŽå¼€å§‹é€šè¿‡ChannelPipelineä¼ é€’å†™äº‹ä»¶ï¼ˆå› ä¸ºè¿™æ˜¯å‡ºç«™æ“ä½œï¼‰ã€‚

![](../.gitbook/assets/image%20%2839%29.png)

â€Œ æ¶ˆæ¯æµç»æ•´ä¸ªChannelPipelineã€‚å¦‚å‰æ‰€è¿°ï¼Œæ‚¨ä¹Ÿå¯ä»¥é€šè¿‡ChannelPipelineæ‰§è¡Œç›¸åŒçš„æ“ä½œã€‚ä»¥ä¸‹æ¸…å•æ˜¾ç¤ºäº†è¿™ä¸€ç‚¹ã€‚

![](../.gitbook/assets/image%20%2845%29.png)

â€Œ æ¶ˆæ¯æµç»æ•´ä¸ªChannelPipelineã€‚æ¯ä¸ªäº‹ä»¶ï¼ˆæ¸…å•6.2å’Œ6.3ï¼‰åœ¨äº‹ä»¶æµæ–¹é¢éƒ½æ˜¯ç›¸ç­‰çš„ã€‚æ‚¨è¿˜åº”è¯¥æ³¨æ„ï¼Œå¯ä»¥é€šè¿‡ChannelHandlerContextè®¿é—®Channelå’ŒChannelPipelineã€‚

å›¾6.3æ˜¾ç¤ºäº†ç”±Channelæˆ–ChannelPipelineè§¦å‘çš„é€šçŸ¥äº‹ä»¶çš„æµç¨‹ã€‚

![](../.gitbook/assets/image%20%2840%29.png)

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ‚¨å¯èƒ½æƒ³åœ¨ChannelPipelineçš„ç‰¹å®šä½ç½®å¼€å§‹ï¼Œè€Œåˆä¸æƒ³è®©å®ƒæµè¿‡æ•´ä¸ªChannelPipelineï¼Œä¾‹å¦‚ï¼š

* To save the overhead of passing the event through extra ChannelHandlers that are not interested in it.
* æŽ’é™¤ä¸€äº›ChannelHandlersã€‚

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ChannelHandlerçš„ChannelHandlerContexté€šçŸ¥æ‚¨é¦–é€‰çš„èµ·ç‚¹ã€‚è¯·æ³¨æ„ï¼Œå®ƒå°†æ‰§è¡Œ**ä½¿ç”¨çš„ChannelHandlerContextçš„ä¸‹ä¸€ä¸ªChannelHandlerï¼Œè€Œä¸æ˜¯å±žäºŽä½¿ç”¨çš„ChannelHandlerContext**ã€‚

æ¸…å•6.4æ˜¾ç¤ºäº†å¦‚ä½•ç›´æŽ¥ä½¿ç”¨ChannelHandlerContextè¿›è¡Œæ“ä½œã€‚

![](../.gitbook/assets/image%20%2853%29.png)

æ¶ˆæ¯å¼€å§‹é€šè¿‡ä¸‹ä¸€ä¸ªChannelHandleræµç»ChannelPipelineåˆ°è¾¾ChanneHandlerContextï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œäº‹ä»¶æµå°†å¯åŠ¨ä¸‹ä¸€ä¸ªChannelHandleråˆ°æ‰€ä½¿ç”¨çš„ChannelHandlerContextã€‚



![](../.gitbook/assets/image%20%2849%29.png)



å¦‚æ‚¨æ‰€è§ï¼Œå®ƒçŽ°åœ¨ä»Žç‰¹å®šçš„ChannelHandlerContextå¼€å§‹ï¼Œå¹¶è·³è¿‡ä¹‹å‰çš„æ‰€æœ‰ChannelHandlerã€‚ä½¿ç”¨ChannelHandlerContextè¿›è¡Œæ“ä½œæ˜¯ä¸€ç§å¸¸è§çš„æ¨¡å¼ï¼Œå¦‚æžœä»ŽChannelHandlerå®žçŽ°ä¸­è°ƒç”¨æ“ä½œï¼Œåˆ™ä½¿ç”¨é¢‘çŽ‡æœ€é«˜ã€‚

\(ä¸€çœ¼çœ‹æ‡‚çš„å¥å­è¯è¯­ä¸å†ç¿»è¯‘ ðŸ˜ƒ \)

You can also use the ChannelHandlerContext from outside, because its thread-safe.

## 6.2.2 ä¿®æ”¹ ChannelPipeline

æ‚¨å¯ä»¥é€šè¿‡è°ƒç”¨pipelineï¼ˆï¼‰æ–¹æ³•æ¥è®¿é—®ChannelHandleræ‰€å±žçš„ChannelPipelineã€‚ä¸€ä¸ªéžå¹³å‡¡çš„åº”ç”¨ç¨‹åºå¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€åœ°åœ¨ChannelPipelineä¸­æ’å…¥ï¼Œåˆ é™¤æˆ–æ›¿æ¢ChannelHandlersã€‚

> NOTE You can keep the ChannelHandlerContext for later use, such as triggering an event outside the handler methods, even from a different Thread.

The following listing shows how you can store the ChannelHandlerContext for later use and then use it even from another thread.

```text
Listing 6.5 ChannelHandlerContext usage 
public class WriteHandler extends ChannelHandlerAdapter {
    private ChannelHandlerContext ctx; 
    
    @Override 
    public void handlerAdded(ChannelHandlerContext ctx) { 
     this.ctx = ctx; #A 
    } 
    public void send(String msg) { #B 
     ctx.write(msg); 
    } 
}
#A Store reference to ChannelHandlerContext for later use 
#B Send message using previously stored ChannelHandlerContext
```

Please note that a ChannelHandler instance can be added to more than one ChannelPipeline if its annotated with the @Sharable.**This means that a single ChannelHandler instance can have more than one ChannelHandlerContext, and therefore the single instance can be invoked with a different ChannelHandlerContext.**

If you try to add a ChannelHandler to more then one ChannelPipeline that is not annotated with **@Sharable** an exception is thrown. Be aware that once you annotate a ChannelHandler with @Sharable it must be safe to use from different threads and also be safe to use with different channels \(connections\) at the same time. Lets look at how it should be used. The following listing shows the correct use of the **@Sharable** annotation.

![](../.gitbook/assets/image%20%2852%29.png)

â€Œ @Sharableçš„ä½¿ç”¨åœ¨è¿™é‡Œæ˜¯æœ‰æ•ˆçš„ï¼Œå› ä¸ºChannelHandlerä¸ä½¿ç”¨ä»»ä½•å­—æ®µæ¥å­˜å‚¨æ•°æ®ï¼Œå› æ­¤å®ƒæ˜¯æ— çŠ¶æ€çš„ã€‚

@Sharableä¹Ÿæœ‰ä¸å¥½çš„ç”¨æ³•ï¼Œå¦‚ä¸‹é¢çš„æ¸…å•æ‰€ç¤ºã€‚

![](../.gitbook/assets/image%20%2851%29.png)

Why is the use of @Sharable wrong here? Its easy to guess once you look at the code. The problem is that were using a field to hold the count of the method calls here. As soon as you add the same instance of the NotSharableHandler to the ChannelPipeline you get bad side effects, such as the count field being accessed and modified by different connections \(and possible threads\) now.

The rule of thumb is to use @Sharable only if youre sure that you can reuse the ChannelHandler on many different channels

> Why share a ChannelHandler ? 
>
> You may wonder why you want to even try to share a ChannelHandler and so annotate it with @Sharable, but there are some situation where it can make sense. First off if you can share it you will need to create less Object which the Garbage Collector needs to recycle later. An other use case would be that you want to mantain some global statistics in the ChannelHandler which are updated by all Channels \(like concurrent connection count\)



