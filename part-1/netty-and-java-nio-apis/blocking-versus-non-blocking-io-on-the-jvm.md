# 1.3 JVM上的阻塞 VS 非阻塞

    Web的持续增长，也增加了对能够处理其规模的网络应用程序的需求。在满足这些需求方面，效率变得很重要。幸运的是，Java自带了创建高效、可伸缩网络程序所需的工具。尽管早期的Java版本已经支持网络编程，但在Java 1.4才引入了NIO API，为写高效的网络程序铺平了道路。

    在Java 7中，引入了新的API（NIO.2\)。它允许我们编写异步网络代码，但尝试提供了一个比之前更高层的API。

    要在Java中完成与网络相关的任务，你可以采用一下两种方法之一：

* 使用IO，即阻塞IO
* 使用NIO，即新/非阻塞IO

> new or non-blocking？
>
> “N"通常意味非阻塞而不是新的。NIO已经存在很长时间了，现在没人再管它叫新IO了。大多数人把它当作非阻塞IO。

    图1.2展示了如何阻塞IO如何使用一个线程处理一个连接，这意味着在连接和线程之间有着一对一的关系，因此，阻塞IO的瓶颈在于你能在JVM中创建的线程数。

![&#x56FE;1.2 &#x963B;&#x585E;IO](../../.gitbook/assets/image%20%282%29.png)

   与此相反，图1.3 展示了阻塞IO怎样让你用一个选择器处理多个连接。

![&#x56FE;1.3 &#x975E;&#x963B;&#x585E;IO](../../.gitbook/assets/image%20%283%29.png)

     在脑海中记着这两张图，让我们更深入地了解阻塞IO和非阻塞IO。我将用一个简单的回声服务来演示IO和NIO的区别。回声服务是指，接收客户端请求并回复从客户端收到的消息。

## 1.3.1. 基于阻塞IO的回声服务

    回声服务的第一个版本基于阻塞IO,这可能是编写网络相关的程序最常见的方法。主要有两个原因：阻塞IO在早期版本的Java中已经存在，并且它相对易用。

