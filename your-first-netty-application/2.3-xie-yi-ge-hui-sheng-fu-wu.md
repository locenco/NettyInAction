# 2.3 写一个回声服务

编写Netty服务端主要包含两个方面：

* 引导配置服务端功能--像线程和端口
* 实现服务器处理程序--构建包含业务逻辑的组件，它决定了当连接和数据被接收时，应该发生什么

## 2.3.1 引导服务端

通过创建ServerBootstrap类的实例来引导服务端。这个实例接下来会被配置，如下所示：设置参数，像端口、线程模型/事件循环,和服务处理器处理业务逻辑（例如，它回显数据，也可以更复杂）。

{% code title="Listing 2.3 Main class for the server" %}
```text
public class NettyEchoServer {
	private final int port;
	EchoServerHandler echoServerHandler =new EchoServerHandler();

	public NettyEchoServer(int port) {
		this.port = port;
	}

	public void start() throws InterruptedException {
		EventLoopGroup group = new NioEventLoopGroup();
		try {
			//1 服务引导
			ServerBootstrap b = new ServerBootstrap();
			//2. 指定nio传输，本地套接字地址
			b.group(group)
					.channel(NioServerSocketChannel.class)
					.localAddress(new InetSocketAddress(port))
					//3. 在管道中添加处理
					.childHandler(new ChannelInitializer<SocketChannel>() {
						@Override
						protected void initChannel(SocketChannel socketChannel) throws Exception {
							//4 Binds server, waits for server to close, and releases resources
							socketChannel.pipeline().addLast(echoServerHandler);
						}
					});
			//5. bind the server and then wait until the bind completes,
			// the call to the "sync()" method will cause this to block until the server is bound.
			ChannelFuture f = b.bind().sync();
			System.out.println(NettyEchoServer.class.getName() + " started and listen on " + f.channel().localAddress());
			// 6. 等待通道关闭
			f.channel().closeFuture().sync();

		} finally {
			// 7. 关闭EventLoopGroup和释放资源
			group.shutdownGracefully().sync();
		}
		
		public static void main(String[] args) throws InterruptedException {
		if (args.length != 1) {
			System.err.println(
					"Usage: " + NettyEchoServer.class.getSimpleName() +
							" <port>");
		}
		int port = Integer.parseInt(args[0]);
		new NettyEchoServer(port).start();
	}
	}
```
{% endcode %}

这个例子看似微不足道，但它完成了第一章和以后的Java示例所有的工作。为了引导服务端，首先创建一个ServerBootstrap实例。因为你在用NIO传输，需要指明**NioEventLoopGroup**去接收新连接和处理接收的连接，指明**NioServerSocketChannel**作为管道的类型，设置InetSocketAddress去绑定到服务端，用来接收新连接。

接着，指明当连接接收后要调用的ChannelHandler，它创建了一个子处理器，这里用的是一个叫**ChannelInitializer**处理器。

尽管第一章的NIO示例是可扩展的，但它们会引起其他问题。例如，线程不容易正确处理。但Netty的设计和抽象封装了大多数你需要做的线程工作。使用到的EventLoopGroup、SocketChannel和ChannelInitializer，每一个都会在以后的章节讨论细节。

ChannelPipeline拥有一个管道的所有不同的ChannelHandler。所以你添加以前写的EchoServerHandler到管道的ChannelPipeline。

您绑定服务器，然后等待直到绑定完成，对sync（）方法的调用将导致此操作阻塞，直到绑定服务器为止。



